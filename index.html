<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scatter Slot Prototype ‚Äî Demo</title>
<style>
  :root{
    --bg:#071023; --panel:#071628; --accent:#f5c84a; --muted:#9fb2d4;
    --box-w:84px; --box-h:84px;
  }
  html,body{height:100%;margin:0;background:#000; font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  /* Background image container */
  #game-wrap{position:relative; max-width:1120px; margin:20px auto; padding:18px; box-sizing:border-box;}
  #game-bg{position:absolute; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; filter:brightness(0.75);}
  /* header / headlines */
  #header {position:relative; z-index:3; display:flex; justify-content:space-between; align-items:center; gap:12px; color:#eaf3ff; margin-bottom:12px;}
  #head-left {display:flex; gap:10px; align-items:center;}
  .headline-wrap {text-align:center; width:480px; position:relative;}
  .headline {font-weight:700; font-size:18px; color:var(--accent); position:absolute; left:0; right:0; opacity:0; transition:opacity .6s;}
  .headline.active{opacity:1}
  /* top-right controls icons */
  .icon-btn{background:rgba(0,0,0,0.35); color:#fff; padding:8px; border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; gap:8px;}
  .icon-small{width:36px;height:36px; display:inline-grid; place-items:center; border-radius:6px;}
  /* main area layout */
  #main {display:flex; gap:16px; position:relative; z-index:3;}
  /* slot board and effects */
  #board-wrap{flex:1; display:flex; flex-direction:column; align-items:center; gap:12px;}
  #ghost {position:absolute; top:48px; left:50%; transform:translateX(-50%); z-index:6; pointer-events:none; transition:all .6s ease;}
  #grid {display:grid; grid-template-columns: repeat(5, var(--box-w)); grid-template-rows: repeat(6, var(--box-h)); gap:8px; padding:12px; background:rgba(5,9,20,0.6); border-radius:12px; border:1px solid rgba(255,255,255,0.03); box-shadow:0 6px 30px rgba(0,0,0,0.6);}
  .cell {width:var(--box-w); height:var(--box-h); background:linear-gradient(180deg,#0a1826,#071226); border-radius:8px; border:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden;}
  .cell .img{font-size:28px; user-select:none;}
  .cell .multi{position:absolute; right:4px; top:4px; background:rgba(0,0,0,0.5); color:#ffd27a; font-weight:700; padding:4px 6px; border-radius:6px; font-size:13px; display:none;}
  .cell.has-mult .multi{display:block}
  .cell.multiplier-anim{animation:pop .6s ease;}
  @keyframes pop {0%{transform:scale(.2);opacity:0}60%{transform:scale(1.25);opacity:1}100%{transform:scale(1)}}
  .cell.crash {animation:crashAnim .5s ease forwards}
  @keyframes crashAnim {0%{transform:scale(1)}50%{transform:scale(1.4);opacity:1}100%{transform:scale(0);opacity:0}}
  /* right panel */
  #right-panel{width:320px; display:flex; flex-direction:column; gap:12px;}
  .panel{background:var(--panel); padding:12px; border-radius:10px; color:var(--muted); box-shadow:0 8px 20px rgba(0,0,0,0.6);}
  .paytable .row{display:flex; justify-content:space-between; padding:6px 0; color:#dfeeff;}
  .small{font-size:13px;color:#9fb2d4}
  /* bottom controls */
  #bottom {display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:12px; z-index:3;}
  .bottom-box{background:linear-gradient(180deg,#120f08,#221b0f); padding:10px 12px; border-radius:10px; color:#fff; font-weight:700; display:flex; align-items:center; gap:8px; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.5);}
  .bottom-box.disabled{opacity:0.45; pointer-events:none}
  #double-pill{background:linear-gradient(90deg,#f2e6cb,#ffd27a); color:#111; padding:8px 10px; border-radius:8px; display:flex; align-items:center; gap:8px;}
  /* spin panel circles */
  #spin-panel{display:flex; flex-direction:column; align-items:center; gap:8px;}
  .controls-row{display:flex; gap:12px; align-items:center;}
  .circle{width:50px;height:50px;border-radius:50%;background:#0f1721;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,0.6)}
  .circle.big{width:88px;height:88px;background:linear-gradient(180deg,#ffd27a,#ffb84a); color:#111; font-weight:800; font-size:18px}
  #speed-control{display:flex; gap:8px; align-items:center; margin-top:6px}
  .speed-btn{padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.06); color:#fff; cursor:pointer; opacity:0.5; font-weight:700}
  .speed-btn.active{opacity:1; background:rgba(255,255,255,0.14)}
  /* modals */
  .modal-bg{position:fixed; inset:0; background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:40}
  .modal{background:#071022; color:#eaf3ff; padding:18px; border-radius:12px; width:720px; max-width:92%; box-shadow:0 20px 60px rgba(0,0,0,0.8)}
  .modal .title{font-size:20px; font-weight:700; color:var(--accent); margin-bottom:8px}
  .close-btn{cursor:pointer; padding:6px 10px; background:rgba(255,255,255,0.04); border-radius:8px}
  /* loading/demo overlay */
  #loadingOverlay{position:fixed; inset:0; background:#000; display:flex; align-items:center; justify-content:center; z-index:100; color:#fff; flex-direction:column}
  #progressBar{width:420px; height:12px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; margin-top:18px}
  #progress{height:100%; width:0; background:linear-gradient(90deg,#ffd27a,#ffb84a)}
  /* congratulation banner */
  .congrats{position:fixed; inset:auto; top:22%; left:50%; transform:translateX(-50%); z-index:50; background:linear-gradient(90deg,#ffd27a,#ffb84a); color:#111; padding:16px 24px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.7); display:none; font-weight:800}
  /* small helper */
  .muted{color:var(--muted); font-size:13px}
</style>
</head>
<body>
<div id="game-wrap">
  <!-- Background (replace src with your castle jpg in repo) -->
  <img id="game-bg" src="background.jpg" alt="background">

  <div id="header">
    <div id="head-left">
      <div class="icon-btn icon-small" id="infoBtn" title="Game info">‚ÑπÔ∏è</div>
      <div class="headline-wrap">
        <div class="headline active" id="headline1">Symbols pay anywhere on the screen</div>
        <div class="headline" id="headline2">Win up to 10,000√ó!</div>
      </div>
    </div>

    <div style="display:flex; gap:12px; align-items:center">
      <div class="icon-btn" id="balancePanel">Credits: <strong id="credits">10000</strong></div>
      <div class="icon-small icon-btn" id="settingsBtn" title="Settings">‚ò∞</div>
    </div>
  </div>

  <div id="main">
    <div id="board-wrap">
      <!-- ghost -->
      <img id="ghost" src="symbols/ghost.png" style="width:80px;height:80px;display:none;" alt="ghost">
      <!-- slot grid -->
      <div id="grid"></div>

      <!-- bottom controls -->
      <div id="bottom" style="width:100%; display:flex; justify-content:space-between; align-items:center;">
        <div id="buyBox" class="bottom-box">BUY FREE SPIN (<span id="buyAmount">0</span>)</div>

        <div id="spin-panel">
          <div class="controls-row">
            <div class="circle" id="bet-decrease">-</div>
            <div class="circle big" id="spinBtn">SPIN</div>
            <div class="circle" id="bet-increase">+</div>
          </div>
          <div id="speed-control" style="margin-top:8px;">
            <div class="speed-btn active" data-speed="slow"> &gt; </div>
            <div class="speed-btn" data-speed="medium"> &gt;&gt; </div>
            <div class="speed-btn" data-speed="fast"> &gt;&gt;&gt; </div>
          </div>
        </div>

        <div id="doubleBox" class="bottom-box" style="display:flex; flex-direction:row; align-items:center; gap:8px;">
          <div style="font-size:13px" id="doubleText">BET <span id="doubleAmount">0</span> DOUBLE CHANCE</div>
          <div id="doubleToggle" class="icon-btn">OFF</div>
        </div>
      </div>
    </div>

    <div id="right-panel">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800;color:var(--accent)">Paytable</div>
          <div class="small">Min Bet ‚Çπ10 ‚Ä¢ Max ‚Çπ1000</div>
        </div>
        <div class="paytable" style="margin-top:8px">
          <!-- paytable rows will be injected -->
          <div id="payRows"></div>
        </div>
      </div>

      <div class="panel small">
        <div style="font-weight:700;color:var(--accent)">Game Info</div>
        <div style="margin-top:8px"><strong>Grid:</strong> 6√ó5 ‚Ä¢ <strong>Win:</strong> 8+ same symbols anywhere ‚Ä¢ <strong>Max Win:</strong> 10,000√ó</div>
        <div style="margin-top:8px" class="muted">Buy Feature costs <span id="buyX">100√ó</span> of current bet. Double Chance adds 25% to displayed bet for extra chance and disables buy feature.</div>
      </div>

      <div class="panel small">
        <div style="font-weight:700;color:var(--accent)">Controls</div>
        <ul style="margin:8px 0 0 18px">
          <li>Speed: Slow / Medium / Fast</li>
          <li>Buy free spins (100√ó bet)</li>
          <li>Double Chance: ON/OFF (extra 25% shown, wins use base bet)</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- Congrats banner -->
<div id="congrats" class="congrats"></div>

<!-- Info modal -->
<div id="infoModal" class="modal-bg">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="title">Game Rules & Paytable</div>
        <div class="small">Symbols pay anywhere. Match 8 or more identical symbols anywhere on the grid to win. Cascades continue until no more wins. Free spins triggered by scatters.</div>
      </div>
      <div class="close-btn" id="infoClose">Close</div>
    </div>
    <hr style="border-color:rgba(255,255,255,0.03); margin:12px 0"/>
    <div id="infoContent" style="max-height:420px; overflow:auto; margin-top:8px">
      <div style="display:flex; gap:12px; flex-wrap:wrap;">
        <!-- symbol preview with payouts -->
        <div style="width:48%; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px;">
          <div style="font-weight:700; color:var(--accent)">Symbols & Payouts</div>
          <div id="infoSymbols" style="margin-top:8px"></div>
        </div>
        <div style="width:48%; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px;">
          <div style="font-weight:700; color:var(--accent)">Scatters</div>
          <div style="margin-top:8px">
            <div>4 scatters ‚Üí 3√ó bet + 15 free spins</div>
            <div>5 scatters ‚Üí 5√ó bet</div>
            <div>6 scatters ‚Üí 20√ó bet</div>
            <div>During bonus: 3+ scatters ‚Üí +5 extra spins</div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div style="font-weight:700;color:var(--accent)">Max Win</div>
        <div class="small">Maximum possible payout is capped at <strong>10,000√ó</strong> the bet.</div>
      </div>
    </div>
  </div>
</div>

<!-- Settings modal -->
<div id="settingsModal" class="modal-bg">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="title">Settings</div>
      <div class="close-btn" id="settingsClose">Close</div>
    </div>
    <div style="margin-top:12px" class="small">
      <div style="display:flex;gap:12px;align-items:center;margin:8px 0">
        <label>Sound</label>
        <input type="checkbox" id="soundToggle" checked>
      </div>
      <div style="display:flex;gap:12px;align-items:center;margin:8px 0">
        <label>Quick Spin</label>
        <input type="checkbox" id="quickSpinToggle">
      </div>
      <div style="display:flex;gap:12px;align-items:center;margin:8px 0">
        <label>Battery Saver</label>
        <input type="checkbox" id="batterySaver">
      </div>
      <div style="display:flex;gap:12px;align-items:center;margin:8px 0">
        <label>Spin Button Lock (auto spin)</label>
        <input type="checkbox" id="spinLock" checked>
      </div>
    </div>
  </div>
</div>

<!-- Loading / demo overlay -->
<div id="loadingOverlay">
  <div style="color:var(--accent);font-weight:800;font-size:22px">Loading game...</div>
  <div id="progressBar"><div id="progress"></div></div>
  <div style="margin-top:14px; color:#fff; opacity:0.9">Please wait ‚Äî preparing demo</div>
  <div style="margin-top:18px">
    <label style="font-size:13px"><input type="checkbox" id="dontShowDemo"> Don't show demo again</label>
  </div>
</div>

<script>
/* --------------------------
   Game configuration & data
   -------------------------- */
const COLS = 5; // 5 columns
const ROWS = 6; // 6 rows
const GRID_SIZE = ROWS * COLS;
const MIN_BET = 10, MAX_BET = 1000;
const MAX_WIN_MULT = 10000;
const MULT_VALUES = [2,3,4,5,6,8,10,20,25,50,100,250,500,1000];

// symbol definitions according to your list (id, label, emoji fallback, payout tiers)
const SYMBOLS = [
  {id:'king', label:'King', emoji:'üëë', payouts:{'8-9':10,'10-11':25,'12-30':50}},
  {id:'timer', label:'Timer', emoji:'‚åõÔ∏è', payouts:{'8-9':2.5,'10-11':10,'12-30':25}},
  {id:'ring', label:'Ring', emoji:'üíç', payouts:{'8-9':2,'10-11':5,'12-30':15}},
  {id:'cup', label:'Cup', emoji:'üèÜ', payouts:{'8-9':1.5,'10-11':2,'12-30':11}},
  {id:'diamond', label:'Diamond', emoji:'üíé', payouts:{'8-9':1,'10-11':1.5,'12-30':10}},
  {id:'shape', label:'Shape', emoji:'‚ô¶Ô∏è', payouts:{'8-9':0.8,'10-11':1.2,'12-30':8}},
  {id:'stop', label:'Stop', emoji:'üõë', payouts:{'8-9':0.5,'10-11':1,'12-30':5}},
  {id:'star', label:'Star', emoji:'üåü', payouts:{'8-9':0.4,'10-11':0.9,'12-30':4}},
  {id:'earth', label:'Earth', emoji:'üåè', payouts:{'8-9':0.25,'10-11':0.75,'12-30':2}},
];
const SCATTER = {id:'scatter', label:'Scatter', emoji:'‚õÑÔ∏è'};

// symbol weight distribution (higher -> more frequent). tweak to control RTP.
const WEIGHTS = {
  king:6, timer:10, ring:12, cup:14, diamond:18, shape:18, stop:20, star:22, earth:10, scatter:6
};

/* --------------------------
   State variables
   -------------------------- */
let balance = 10000;
let bet = 10;
let doubleChance = false;
let spinSpeed = 'slow'; // 'slow' | 'medium' | 'fast'
let autoSpinLock = true; // spin button lock (settings)
let quickSpin = false;
let soundOn = true;
let batterySaver = false;
let grid = new Array(GRID_SIZE).fill(null);
let inBonus = false;
let freeSpinsLeft = 0;
let bonusTotalMultiplier = 0; // accumulated during bonus
let lastWin = 0;

/* --------------------------
   Utility helpers
   -------------------------- */
function $(id){return document.getElementById(id)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

/* Build a weighted pool for random draws */
let weightedPool = null;
function buildWeightedPool(){
  weightedPool = [];
  for(const sym of SYMBOLS){
    const w = WEIGHTS[sym.id] || 10;
    for(let i=0;i<w;i++) weightedPool.push(sym);
  }
  for(let i=0;i< (WEIGHTS[SCATTER.id]||6); i++) weightedPool.push(SCATTER);
}
buildWeightedPool();

function pickRandomSymbol(){
  return weightedPool[Math.floor(Math.random()*weightedPool.length)];
}

/* --------------------------
   UI initialization
   -------------------------- */
const gridEl = $('grid');
const creditsEl = $('credits');
const buyBox = $('buyBox');
const buyAmountEl = $('buyAmount');
const buyXEl = $('buyX');
const doubleAmountEl = $('doubleAmount');
const doubleToggle = $('doubleToggle');
const spinBtn = $('spinBtn');
const decreaseBtn = $('bet-decrease');
const increaseBtn = $('bet-increase');
const speedBtns = document.querySelectorAll('.speed-btn');
const infoBtn = $('infoBtn');
const settingsBtn = $('settingsBtn');
const infoModal = $('infoModal');
const settingsModal = $('settingsModal');
const infoClose = $('infoClose');
const settingsClose = $('settingsClose');
const loadingOverlay = $('loadingOverlay');
const progressEl = $('progress');
const dontShowDemo = $('dontShowDemo');
const congratsEl = $('congrats');

/* prepare paytable display in right panel and info modal */
function setupPaytableUI(){
  const payRows = $('payRows');
  payRows.innerHTML = '';
  for(const s of SYMBOLS){
    const div = document.createElement('div');
    div.className = 'row';
    div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="font-size:18px">${s.emoji}</div><div style="font-weight:700;color:#fff">${s.label}</div></div>
      <div style="text-align:right;color:#dfeeff">
        8-9: ${s.payouts['8-9']}√ó<br>10-11: ${s.payouts['10-11']}√ó<br>12+: ${s.payouts['12-30']}√ó</div>`;
    payRows.appendChild(div);
  }

  // info modal symbol list
  const infoSymbols = $('infoSymbols');
  infoSymbols.innerHTML = '';
  for(const s of SYMBOLS){
    const el = document.createElement('div');
    el.style.display='flex'; el.style.justifyContent='space-between'; el.style.margin='6px 0'; el.style.color='#eaf3ff';
    el.innerHTML = `<div>${s.emoji} <strong style="margin-left:6px">${s.label}</strong></div><div style="text-align:right">
      ${s.payouts['8-9']}√ó / ${s.payouts['10-11']}√ó / ${s.payouts['12-30']}√ó</div>`;
    infoSymbols.appendChild(el);
  }
}
setupPaytableUI();

/* --------------------------
   Grid rendering & cell helpers
   -------------------------- */
function createGridCells(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.idx = idx;
      cell.innerHTML = `<div class="img"> </div><div class="multi"></div>`;
      gridEl.appendChild(cell);
    }
  }
}
createGridCells();

/* Draw grid (images or emoji) */
function renderGrid(){
  for(let i=0;i<GRID_SIZE;i++){
    const cell = gridEl.children[i];
    const img = cell.querySelector('.img');
    const multi = cell.querySelector('.multi');
    const sym = grid[i];
    if(!sym){ img.textContent = ''; multi.textContent=''; cell.classList.remove('has-mult'); continue; }
    // prefer image assets: symbols/{id}.png else emoji fallback
    const imgPath = `symbols/${sym.id}.png`;
    // simple check: we won't check file existence; use emoji fallback for demo
    img.textContent = sym.emoji || sym.id;
    if(sym.multValue){
      multi.textContent = sym.multValue + 'X';
      cell.classList.add('has-mult');
    } else {
      multi.textContent = '';
      cell.classList.remove('has-mult');
    }
  }
}
  
/* Fill grid randomly but obey scatter placement constraint:
   - no more than 1 scatter per row AND per column.
*/
function fillGridRandomly(){
  // create empty
  grid = new Array(GRID_SIZE).fill(null);

  // first decide a random number of scatters this spin (rare): 0..maxScat
  const maxScat = 6; // physically limited by rows & cols
  const scatChance = Math.random();
  let scatCount = 0;
  if(scatChance < 0.06) scatCount = 4; // occasional 4
  else if(scatChance < 0.09) scatCount = 5;
  else if(scatChance < 0.095) scatCount = 6;
  else if(scatChance < 0.3) scatCount = (Math.random()<0.08?1:0); // small chance 1
  // but we can also leave scatCount=0 to be common

  // ensure we don't exceed rows/cols
  scatCount = Math.min(scatCount, ROWS, COLS);

  const usedRows = new Set(), usedCols = new Set();
  let attempts = 0;
  while(scatCount > 0 && attempts < 200){
    const r = Math.floor(Math.random()*ROWS);
    const c = Math.floor(Math.random()*COLS);
    if(usedRows.has(r) || usedCols.has(c)){ attempts++; continue; }
    const idx = r*COLS + c;
    grid[idx] = SCATTER;
    usedRows.add(r); usedCols.add(c);
    scatCount--;
  }

  // fill remaining with random symbols (from weighted pool)
  for(let i=0;i<GRID_SIZE;i++){
    if(!grid[i]){
      grid[i] = pickRandomSymbol();
      // ensure not placing scatter here (we already handled scat placement)
      if(grid[i].id === SCATTER.id){
        // replace by another random non-scatter symbol
        const nonScatter = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
        grid[i] = nonScatter;
      }
    }
  }
  renderGrid();
}

/* --------------------------
   Gameplay logic: evaluate counts, payouts, tumbles
   -------------------------- */
function countSymbolsOnGrid(){
  const counts = {};
  for(const s of grid){
    counts[s.id] = (counts[s.id]||0) + 1;
  }
  return counts;
}

/* determine payout multiplier for a symbol id and count */
function payoutForSymbol(symId, count){
  const s = SYMBOLS.find(x=>x.id===symId);
  if(!s) return 0;
  if(count>=12) return s.payouts['12-30'];
  if(count>=10) return s.payouts['10-11'];
  if(count>=8) return s.payouts['8-9'];
  return 0;
}

/* compute base wins (per cascade) and which indices to remove */
function evaluateWins(){
  const counts = {};
  for(let i=0;i<grid.length;i++){
    const s = grid[i];
    counts[s.id] = counts[s.id] ? counts[s.id]+1 : 1;
  }
  const winners = [];
  for(const sym of SYMBOLS){
    const cnt = counts[sym.id] || 0;
    if(cnt >= 8){
      // remove all tiles of this symbol (as per design)
      for(let i=0;i<grid.length;i++){
        if(grid[i].id === sym.id) winners.push(i);
      }
    }
  }
  return winners;
}

/* remove indices and collapse columns; new tiles spawn at top */
function collapseAndRefill(removeIdxs, speedMode='slow'){
  // mark removals
  const toRemove = new Set(removeIdxs);
  // for each column, build new column from bottom to top
  for(let c=0;c<COLS;c++){
    const col = [];
    // read bottom-up (row index ROWS-1..0)
    for(let r=ROWS-1;r>=0;r--){
      const idx = r*COLS + c;
      if(!toRemove.has(idx)){
        col.push(grid[idx]);
      }
    }
    // now fill with new random symbols to reach ROWS
    while(col.length < ROWS){
      // new tile spawn can sometimes be a multiplier (tumble multiplier chance)
      let newSym = pickRandomSymbol();
      if(newSym.id === SCATTER.id) {
        // don't spawn scatter during refill to keep fair distribution
        newSym = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
      }
      // 30% chance to spawn multiplier during tumble in base, but less in base and 1-2 in bonus
      col.push(newSym);
    }
    // write back bottom-up
    for(let r=ROWS-1;r>=0;r--){
      grid[r*COLS + c] = col[ROWS-1 - r];
    }
  }
}

/* attempt to spawn multipliers during tumble or spin:
   - baseGame: small chance per cascade to spawn 0..2 multipliers that apply to that cascade
   - bonusGame: small chance spawn 0..2 multipliers that are added to bonusTotalMultiplier
*/
function maybeSpawnMultipliersDuringTumble(isBonus){
  const chance = isBonus ? 0.45 : 0.35; // tweakable
  if(Math.random() > chance) return []; // none spawned
  const count = Math.floor(Math.random()*2) + 1; // 1 or 2
  const spawned = [];
  for(let i=0;i<count;i++){
    const value = MULT_VALUES[Math.floor(Math.random()*MULT_VALUES.length)];
    // place on a random empty cell or replace a low-value symbol
    const idx = Math.floor(Math.random()*GRID_SIZE);
    // attach mult value to that grid cell (for visuals & calculation)
    grid[idx].multValue = value;
    spawned.push({idx, value});
    // sound per range:
    playMultiplierSound(value);
    // ghost animation:
    showGhostAtCell(idx, value);
    if(isBonus){
      bonusTotalMultiplier += value;
    }
  }
  return spawned;
}

/* count scatters on grid */
function countScatters(){
  let cnt=0;
  for(const s of grid) if(s.id===SCATTER.id) cnt++;
  return cnt;
}

/* compute spin payout for one cascade step (before multipliers) */
function computeCascadeBaseWin(){
  const counts = {};
  for(const s of grid) counts[s.id] = (counts[s.id]||0) + 1;
  let baseMult = 0;
  for(const sym of SYMBOLS){
    const cnt = counts[sym.id] || 0;
    if(cnt >= 8){
      baseMult += payoutForSymbol(sym.id, cnt);
    }
  }
  return baseMult;
}

/* Run a full spin: fill grid, evaluate cascades until no more winners.
   Returns totalWin (in currency), scattersCount, cascadesCount
*/
async function runSpin({isFree=false} = {}){
  // deduct bet if not a free spin
  const effectiveBet = bet;
  if(!isFree){
    const displayedBet = doubleChance ? +(bet * 1.25).toFixed(2) : bet;
    // double chance's extra 0.25 does not affect wins (we do not subtract differently from balance here)
    if(balance < (doubleChance?+(bet*1.25).toFixed(2):bet)){
      showMessage("Not enough balance");
      return;
    }
    // deduct displayed amount: if doubleChance is ON, we charge 1.25*bet
    balance -= (doubleChance ? +(bet*1.25).toFixed(2) : bet);
  }

  updateUI();

  // initial spin grid fill with speed animation
  fillGridRandomly();
  await animateInitialPlacement();

  let totalWin = 0;
  let cascades = 0;
  let continueTumble = true;

  // bonus-specific: keep accumulating multipliers in bonusTotalMultiplier
  while(continueTumble){
    cascades++;
    // evaluate base winners (8+ groups)
    const winners = evaluateWins();
    if(winners.length === 0){
      // no win this cascade
      // after initial spin, spawn base multipliers sometimes (per design optional)
      // no need to collapse
      break;
    }
    // compute base multiplier (sum of payout rates) for this cascade
    const baseRate = computeCascadeBaseWin(); // e.g., 2√ó + ...
    // any multipliers present on the grid for this cascade?
    // calculate sum multiplier for this cascade (base game: apply to cascade only; bonus: apply accumulated)
    let cascadeMult = 1;
    // gather multipliers attached to grid
    let cascadeAddedMult = 0;
    for(const widx of winners){
      if(grid[widx] && grid[widx].multValue){
        cascadeAddedMult += grid[widx].multValue;
      }
    }
    // also consider multipliers that exist anywhere on grid (design choice)
    for(const cell of grid){
      if(cell && cell.multValue){
        cascadeAddedMult += cell.multValue;
      }
    }
    // In base game, cascade multiplier should be (1 + sum of mults)? But you specified they multiply the entire cascade.
    // We'll treat multipliers as additive to a multiplier factor: totalMult = 1 + sum(multValues)
    if(cascadeAddedMult > 0){
      cascadeMult = 1 + cascadeAddedMult;
    }
    // If in bonus, also add bonusTotalMultiplier (accumulated) to apply
    if(inBonus){
      cascadeMult = 1 + bonusTotalMultiplier + cascadeAddedMult;
    }

    // compute cascade win
    const cascadeWin = Math.round(baseRate * cascadeMult * effectiveBet);
    // enforce max win cap
    const cappedWin = Math.min(cascadeWin, effectiveBet * MAX_WIN_MULT);
    totalWin += cappedWin;

    // animate crashes
    animateCrashIndices(winners);
    // remove winners and collapse/fill
    await delay(getCrashDelay());
    collapseAndRefill(winners);
    // after refill possibly spawn multipliers during tumble
    const spawned = maybeSpawnMultipliersDuringTumble(inBonus);
    renderGrid();
    await delay(getDropDelay());
  }

  // after cascades, count scatters
  const scatCount = countScatters();

  // Scatter payouts added to totalWin
  if(scatCount >= 4){
    // Scatter payouts per table: 4->3x, 5->5x, 6->20x
    let scatPayout = 0;
    if(scatCount === 4) scatPayout = 3;
    else if(scatCount === 5) scatPayout = 5;
    else if(scatCount >= 6) scatPayout = 20;
    const sp = Math.round(effectiveBet * scatPayout);
    totalWin += sp;
    // trigger free spins when >=4 scatters
    if(!inBonus && scatCount >= 4){
      // delay a bit and show big congrats & ask to start 15 free spins
      showCongratsBanner(`Congratulations! You hit ${scatCount} scatters and won ${scatPayout}√ó bet! Click to start 15 free spins.`, ()=>{ startBonus(15); });
      // we return totalWin now and let player click to start bonus (as requested)
    }
  }

  // award win to player balance
  balance += totalWin;
  lastWin = totalWin;
  updateUI();
  // if in bonus and free spins are active, handle them externally
  return {win: totalWin, scatters: scatCount};
}

/* --------------------------
   Animation helpers
   -------------------------- */
function delay(ms){ return new Promise(r => setTimeout(r, ms)); }
function getDropDelay(){
  if(spinSpeed === 'slow') return 120; // per column incremental delay uses elsewhere
  if(spinSpeed === 'medium') return 0;
  return 0;
}
function getCrashDelay(){
  if(spinSpeed === 'slow') return 600;
  if(spinSpeed === 'medium') return 500;
  return 120;
}

/* initial placement animation */
async function animateInitialPlacement(){
  if(spinSpeed === 'slow'){
    // animate column by column
    for(let c=0;c<COLS;c++){
      for(let r=0;r<ROWS;r++){
        const idx = r*COLS + c;
        const cell = gridEl.children[idx];
        const img = cell.querySelector('.img');
        img.style.transform = 'translateY(-40px)'; img.style.opacity=0;
        setTimeout(()=>{ img.style.transition='transform .35s, opacity .35s'; img.style.transform='translateY(0)'; img.style.opacity=1; }, 20);
      }
      await delay(120);
    }
  } else {
    renderGrid();
  }
  renderGrid();
}

/* animate a set of indices crashing */
function animateCrashIndices(indices){
  // add crash class for visual effect then remove
  for(const idx of indices){
    const cell = gridEl.children[idx];
    cell.classList.add('crash');
    // clear symbol content after animation
    setTimeout(()=>{ cell.classList.remove('crash'); }, getCrashDelay()+50);
  }
  // remove multValues for removed indices
  for(const idx of indices) if(grid[idx]) delete grid[idx].multValue;
}

/* ghost effect: show ghost and a multiplier pop at cell location */
function showGhostAtCell(idx, value){
  const cell = gridEl.children[idx];
  const rect = cell.getBoundingClientRect();
  const ghost = $('ghost');
  // place ghost over the cell (animation)
  ghost.style.display = 'block';
  const gw = ghost.getBoundingClientRect();
  ghost.style.left = (rect.left + rect.width/2) + 'px';
  ghost.style.top = (rect.top - 80) + 'px';
  setTimeout(()=>{ ghost.style.top = (rect.top + 6) + 'px'; }, 60);
  // show multiplier pop
  const pop = document.createElement('div');
  pop.textContent = value + 'X';
  pop.style.position='fixed'; pop.style.left=(rect.left+12)+'px'; pop.style.top=(rect.top+8)+'px';
  pop.style.zIndex=30; pop.style.fontWeight='900'; pop.style.color='#ffd27a'; pop.style.fontSize='20px';
  document.body.appendChild(pop);
  setTimeout(()=>{ pop.remove(); ghost.style.display='none'; }, 900);
}

/* play multiplier sound placeholder */
function playMultiplierSound(value){
  if(!soundOn) return;
  // choose sound per range (placeholder: console log)
  if(value >= 1000) console.log('Play stone-drop sound');
  else if(value >= 100) console.log('Play heavy gangster sound');
  else if(value >= 10) console.log('Play medium gangster sound');
  else console.log('Play light zap sound');
}

/* simple message */
function showMessage(text){
  alert(text);
}

/* show congrats banner with optional click handler */
function showCongratsBanner(text, onClick){
  congratsEl.textContent = text;
  congratsEl.style.display = 'block';
  congratsEl.onclick = ()=>{
    congratsEl.style.display='none';
    if(onClick) onClick();
  };
  setTimeout(()=>{ congratsEl.style.display='none'; congratsEl.onclick=null; }, 4000);
}

/* --------------------------
   Bonus handling
   -------------------------- */
function startBonus(spins=15){
  inBonus = true;
  freeSpinsLeft = spins;
  bonusTotalMultiplier = 0;
  // update UI (background music swap could happen here)
  showMessage(`Bonus started: ${spins} free spins`);
  autoRunBonus();
}

/* run bonus automatically: user can only control speed */
async function autoRunBonus(){
  while(freeSpinsLeft > 0){
    // run a free spin (no bet deduction)
    await runSpin({isFree:true});
    freeSpinsLeft--;
    // if scatters >=3 during bonus (retrigger) add +5 spins - not implemented here explicitly but you can check runSpin return
    updateUI();
    await delay(200); // small gap
  }
  inBonus = false;
  showCongratsBanner(`Bonus ended! You won during bonus.`, null);
}

/* --------------------------
   UI & events
   -------------------------- */
function updateUI(){
  creditsEl.textContent = balance;
  buyAmountEl.textContent = (bet * 100).toFixed(0);
  buyXEl.textContent = '100√ó';
  doubleAmountEl.textContent = (doubleChance ? (bet * 1.25).toFixed(2) : bet.toFixed(2));
  $('doubleAmount').textContent = (doubleChance ? (bet * 1.25).toFixed(2) : bet.toFixed(2));
  renderGrid();
}

/* spin button click */
spinBtn.addEventListener('click', async ()=>{
  if(autoSpinLock && spinBtn.dataset.busy==='1') return;
  spinBtn.dataset.busy='1'; spinBtn.style.opacity=0.6;
  await runSpin({isFree:false});
  spinBtn.dataset.busy='0'; spinBtn.style.opacity=1;
});

/* bet controls */
decreaseBtn.addEventListener('click', ()=>{
  bet = Math.max(MIN_BET, bet - 10);
  updateUI();
});
increaseBtn.addEventListener('click', ()=>{
  bet = Math.min(MAX_BET, bet + 10);
  updateUI();
});

/* buy feature */
buyBox.addEventListener('click', ()=>{
  if(doubleChance){ showMessage('Disable Double Chance to buy feature'); return; }
  const cost = bet * 100;
  if(balance < cost){ showMessage('Not enough balance'); return; }
  balance -= cost;
  updateUI();
  startBonus(15);
});

/* double chance toggle */
doubleToggle.addEventListener('click', ()=>{
  doubleChance = !doubleChance;
  doubleToggle.textContent = doubleChance ? 'ON' : 'OFF';
  // disable buy when double is ON
  if(doubleChance) buyBox.classList.add('disabled'); else buyBox.classList.remove('disabled');
  updateUI();
});

/* speed buttons */
speedBtns.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    speedBtns.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    spinSpeed = btn.dataset.speed;
  });
});

/* info/settings */
infoBtn.addEventListener('click', ()=>{ infoModal.style.display='flex'; });
infoClose.addEventListener('click', ()=> infoModal.style.display='none');
settingsBtn.addEventListener('click', ()=> settingsModal.style.display='flex');
settingsClose.addEventListener('click', ()=> settingsModal.style.display='none');

$('soundToggle').addEventListener('change', e=>{ soundOn = e.target.checked });
$('quickSpinToggle').addEventListener('change', e=>{ quickSpin = e.target.checked });
$('batterySaver').addEventListener('change', e=>{ batterySaver = e.target.checked });
$('spinLock').addEventListener('change', e=>{ autoSpinLock = e.target.checked });

/* loading overlay simulation & demo auto-start */
(async function startup(){
  // animate loading
  for(let p=0;p<=100;p+=2){
    progressEl.style.width = p + '%';
    await delay(20);
  }
  // small demo overlay - we hide if user checked don't show
  loadingOverlay.style.display='none';
  // initial populate
  fillGridRandomly();
  updateUI();
})();

</script>
</body>
</html>
